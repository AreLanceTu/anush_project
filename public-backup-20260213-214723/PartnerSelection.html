<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Find Your Partner â€“ Vivah</title>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; min-height: 100%; }
    body {
      background: linear-gradient(180deg, #8b1f26 0%, #6c161a 55%, #3b0b0d 100%);
      background-attachment: fixed;
      background-size: cover;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      color: #fff;
      font-family: 'Montserrat', sans-serif;
    }

    .hero {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      padding: 40px 20px;
    }

    .overlay {
      position: absolute; inset: 0; background: linear-gradient(rgba(0,0,0,0.12), rgba(0,0,0,0.18)); z-index: 0;
    }

    .container {
      position: relative; z-index: 2;
      width: 760px; max-width: 96%;
      display: flex; flex-direction: column; align-items: center;
      gap: 20px;
    }

    h1 {
      font-size: 28px; font-weight: 700; letter-spacing: 0.02em;
      margin-bottom: 6px; color: #fff;
    }

    .subtitle { color: rgba(255,255,255,0.9); margin-bottom: 12px; font-size: 14px; }

    /* Cards layout - centered grid with responsive columns */
    .selection-cards {
      display: grid;
      grid-template-columns: repeat(2, minmax(280px, 340px));
      gap: 28px; align-items: stretch;
      justify-content: center; justify-items: center; margin: 0 auto;
      perspective: 1000px;
    }

    .card {
      min-height: 480px; width: 100%; border-radius: 18px; padding: 36px 26px; position: relative; overflow: visible;
      cursor: pointer; transition: transform .45s cubic-bezier(.2,.9,.2,1), box-shadow .45s ease;
      box-shadow: 0 40px 60px rgba(2, 6, 23, 0.35);
      display: flex; flex-direction: column; align-items: center; justify-content: space-between;
      text-align: center; color: #fff;
      background: linear-gradient(180deg, rgba(255,255,255,0.06) 0%, rgba(255,255,255,0.02) 100%);
      border: 1px solid rgba(255,255,255,0.07);
    }

    /* Align cards evenly (user requested same alignment for both) */
    .card { transform: translateY(0); }

    .card:hover { transform: translateY(-12px) scale(1.02); box-shadow: 0 50px 80px rgba(10, 10, 30, 0.45); }

    /* specific color themes (both dark red to match page background) */
    .card.female, .card.male { background: linear-gradient(180deg, #8b1f26 0%, #5d1418 80%); border: 1px solid rgba(255,255,255,0.06); }

    /* subtle highlight variants if needed later */
    .card.female.highlight { background: linear-gradient(180deg, #9c2b2f 0%, #6a171a 80%); }
    .card.male.highlight { background: linear-gradient(180deg, #9c2b2f 0%, #6a171a 80%); }

    /* Decorative concentric rings inside card */
    .card::before {
      content: '';
      position: absolute; width: 370px; height: 370px; left: 50%; top: 60px; transform: translateX(-50%);
      background: radial-gradient(circle, rgba(255,255,255,0.06) 0%, rgba(255,255,255,0.02) 30%, transparent 40%);
      border-radius: 50%; filter: blur(6px); z-index: 0;
      pointer-events: none;
    }

    .card-icon {
      z-index: 2; display: inline-flex; align-items: center; justify-content: center;
      width: 180px; height: 180px; border-radius: 50%; margin-top: 36px; margin-bottom: 26px;
      background: rgba(255,255,255,0.06); box-shadow: inset 0 -6px 24px rgba(0,0,0,0.25); overflow: hidden;
    }

    .card-icon img.avatar { width: 100%; height: 100%; object-fit: cover; display: block; border-radius: 50%; }

    /* Particles & hearts canvas */
    .particles {
      position: absolute;
      inset: 0;
      z-index: 1;
      pointer-events: none;
    }

    /* Slightly stronger card shadow to read against dark-red background */
    .card { box-shadow: 0 44px 70px rgba(0,0,0,0.45); }
    .card.selected { box-shadow: 0 60px 110px rgba(10,10,30,0.65); border: 1px solid rgba(255,255,255,0.12); }

    .card-title { z-index: 2; font-size: 22px; font-weight: 700; margin-top: 6px; margin-bottom: 6px; }
    .card-description { z-index: 2; font-size: 13px; opacity: 0.95; margin-bottom: 22px; }

    .dotted-line { width: 80px; height: 2px; border-bottom: 2px dashed rgba(255,255,255,0.22); margin: 8px auto 20px; }

    /* small dots on right side */
    .card .dots { position: absolute; right: 18px; top: 46px; display: flex; flex-direction: column; gap: 8px; z-index: 3; }
    .card .dots span { width: 6px; height: 6px; background: rgba(255,255,255,0.6); border-radius: 50%; opacity: 0.9; }

    .swipe { margin-top: auto; color: rgba(255,255,255,0.85); font-size: 12px; padding-bottom: 18px; display:flex; align-items:center; gap:8px; }
    .swipe svg { opacity: 0.9; width:18px; height:18px; }

    /* Selected state */
    .card.selected { transform: translateY(-18px) scale(1.04); box-shadow: 0 60px 110px rgba(10,10,30,0.55); border: 1px solid rgba(255,255,255,0.18); }

    /* Toast messages (this file previously had the elements but no styles) */
    .error-message,.success-message{
      display:none;
      width:min(520px, 92%);
      padding:12px 14px;
      border-radius:12px;
      text-align:center;
      font-weight:700;
      margin: 4px auto 10px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .error-message{
      background: rgba(255, 77, 109, 0.18);
      border: 1px solid rgba(255, 77, 109, 0.35);
      color:#fff;
    }
    .success-message{
      background: rgba(46, 204, 113, 0.14);
      border: 1px solid rgba(46, 204, 113, 0.35);
      color:#fff;
    }

    /* Buttons area (centered with equal widths) */
    .button-group { width: 340px; max-width: 90%; display:flex; gap:20px; margin: 18px auto 0; justify-content: space-between; }
    .btn-back, .btn-continue { flex: 1; padding: 14px 18px; border-radius: 10px; border:none; font-weight:700; }
    .btn-back { background: rgba(255,255,255,0.15); color: #fff; }
    .btn-continue { background: #ff2d55; color:#fff; }

    @media (max-width: 880px) {
      .selection-cards { grid-template-columns: 1fr; gap: 18px; }
      .card, .button-group { width: auto; max-width: 420px; }
      .button-group { gap: 12px; flex-direction: column; }
      .btn-back, .btn-continue { width: 100%; flex: none; }
      .card::before { display:none; }
      .card-icon { width:140px; height:140px; font-size:58px; }
    }

  </style>
</head>
<body>
  <div class="hero">
    <div class="overlay"></div>
    <canvas id="particlesCanvas" class="particles" aria-hidden="true"></canvas>

    <div class="container">
      <h1>Select Gender</h1>
     

      <div id="errorMessage" class="error-message"></div>
      

      <form id="partnerSelectionForm">
        <div class="selection-cards">
          <div class="card male" data-gender="male">
            <span class="card-icon"><img src="images/Male.png" alt="Male avatar" class="avatar"></span>
            <div class="card-title">I'm Looking for a Woman</div>
            <div class="card-description">Find your perfect bride</div>
          </div>

          <div class="card female" data-gender="female">
            <span class="card-icon"><img src="images/Female.png" alt="Female avatar" class="avatar"></span>
            <div class="card-title">I'm Looking for a Man</div>
            <div class="card-description">Find your perfect groom</div>
          </div>
        </div>

        <input type="hidden" id="selectedGender" name="selectedGender" value="">

        <div class="loading" id="loading">
          <div class="spinner"></div>
        </div>

        <!-- Navigation buttons removed as requested -->
      </form>
    </div>
  </div>

  <script type="module">
    import { auth, database } from "./firebase-config.js";
    import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
    import { ref, update } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-database.js";
    import { applyPendingPaymentProfileSync } from "./script.js/profile-sync.js";

    // Best-effort: if a payment just happened, sync name/username now.
    applyPendingPaymentProfileSync({ auth, database }).catch(() => {});

    const cards = document.querySelectorAll('.card')
    const selectedGenderInput = document.getElementById('selectedGender')
    const form = document.getElementById('partnerSelectionForm')
    const errorMessage = document.getElementById('errorMessage')
    const loading = document.getElementById('loading')

    let selectedGender = null

    // Card selection with auto-save and redirect
    cards.forEach(card => {
      card.addEventListener('click', function() {
        cards.forEach(c => c.classList.remove('selected'))
        this.classList.add('selected')
        selectedGender = this.dataset.gender
        selectedGenderInput.value = selectedGender
        // Immediately save preference and move forward since buttons were removed
        submitPreference()
      })
    })

    function genderLabelFromSelection(sel) {
      if (sel === 'male') return 'Men'
      if (sel === 'female') return 'Women'
      return ''
    }

    async function bestEffortSaveGenderToFirebase(genderLabel) {
      if (!genderLabel) return
      try {
        const u = auth.currentUser
        if (u?.uid) {
          await update(ref(database, 'editprofile/' + u.uid), { gender: genderLabel, updatedAt: new Date().toISOString() })
          return
        }
      } catch {
        // ignore
      }

      await new Promise((resolve) => {
        const timeoutId = setTimeout(() => {
          try { unsubscribe?.() } catch {}
          resolve()
        }, 1200)

        const unsubscribe = onAuthStateChanged(auth, async (u) => {
          if (!u?.uid) return
          try {
            await update(ref(database, 'editprofile/' + u.uid), { gender: genderLabel, updatedAt: new Date().toISOString() })
          } catch {
            // ignore
          }
          clearTimeout(timeoutId)
          try { unsubscribe() } catch {}
          resolve()
        })
      })
    }

    async function submitPreference() {
      if (!selectedGender) {
        showError('Please select a preference')
        return
      }

      try {
        showLoading(true)

        // Save preference to localStorage (or you can send to backend)
        localStorage.setItem('partnerPreference', selectedGender)
        localStorage.setItem('preferenceTimestamp', new Date().toISOString())

        const genderLabel = genderLabelFromSelection(selectedGender)
        if (genderLabel) {
          localStorage.setItem('vivah_gender', genderLabel)
          await bestEffortSaveGenderToFirebase(genderLabel)
        }

        // Short delay to show the loading state
        await new Promise(resolve => setTimeout(resolve, 500))

        showLoading(false)

        // Redirect to appropriate matches page
        setTimeout(() => {
          if (selectedGender === 'female') {
            // go to the female-focused matches page
            window.location.href = 'MatchesFemale.html'
          } else {
            // default matches (for male / other)
            window.location.href = 'Matches.html'
          }
        }, 650)
      } catch (error) {
        showLoading(false)
        showError(error.message || 'An error occurred. Please try again.')
      }
    }

    // Keep form submit as fallback (calls the same handler)
    form.addEventListener('submit', (e) => {
      e.preventDefault()
      submitPreference()
    })

    function showError(message) {
      errorMessage.textContent = message
      errorMessage.style.display = 'block'
      setTimeout(() => {
        errorMessage.style.display = 'none'
      }, 5000)
    }

    function showLoading(show) {
      loading.style.display = show ? 'block' : 'none'
    }

    // Particle + heart animation
    (function() {
      const canvas = document.getElementById('particlesCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      let w = 0, h = 0, devicePixelRatio = window.devicePixelRatio || 1;
      let particles = [];
      // Increased limits and configurable spawn settings for denser visuals
      const MAX_PARTICLES = window.innerWidth < 480 ? 240 : 800;
      const HEART_CHANCE = 0.18; // probability of a heart particle
      const SPAWN_CHANCE = 0.98; // per-frame spawn probability
      const PULSE_COUNT = window.innerWidth < 480 ? 10 : 28;
      // Make particles and hearts smaller and more translucent
      const PARTICLE_OPACITY = 0.20; // global max opacity (0-1)
      // Movement: gentle wandering parameters
      const WIGGLE_AMP_RANGE = [0.2, 1.2];
      const WIGGLE_SPEED_RANGE = [0.008, 0.05];
      // Cluster/group spawn (spawn hearts and dots together)
      const CLUSTER_CHANCE = 0.26; // per-frame chance to form a small cluster
      const CLUSTER_HEARTS_MIN = 1;
      const CLUSTER_HEARTS_MAX = 4;
      const CLUSTER_DOTS_MIN = 5;
      const CLUSTER_DOTS_MAX = 18;
      const CLUSTER_RADIUS_BASE = 80; // px (scaled by screen size)

      function resize() {
        devicePixelRatio = window.devicePixelRatio || 1;
        w = canvas.width = Math.floor(canvas.clientWidth * devicePixelRatio);
        h = canvas.height = Math.floor(canvas.clientHeight * devicePixelRatio);
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      }
      window.addEventListener('resize', resize);
      resize();

      function rand(min, max) { return Math.random() * (max - min) + min; }

      function createParticle() {
        const isHeart = Math.random() < HEART_CHANCE; // hearts are more frequent
        // Smaller sizes and slower vertical motion for a delicate float
        const size = isHeart ? rand(6, 12) : rand(0.6, 2.2);
        const wiggleAmp = rand(WIGGLE_AMP_RANGE[0], WIGGLE_AMP_RANGE[1]);
        const wiggleSpeed = rand(WIGGLE_SPEED_RANGE[0], WIGGLE_SPEED_RANGE[1]);
        return {
          x: rand(0, canvas.clientWidth),
          y: canvas.clientHeight + rand(2, 180),
          vx: rand(-0.15, 0.15),
          vy: isHeart ? rand(-0.35, -0.9) : rand(-0.4, -1.4),
          size,
          life: rand(320, 1200),
          age: 0,
          rotation: rand(0, Math.PI * 2),
          spin: rand(-0.01, 0.01),
          alpha: 0,
          kind: isHeart ? 'heart' : 'dot',
          // hearts get red/pink hues, dots get warm/pale tones
          hue: isHeart ? (Math.random() < 0.6 ? rand(340, 360) : rand(0, 20)) : rand(30, 80),
          // maxAlpha keeps overall opacity low
          maxAlpha: PARTICLE_OPACITY * rand(0.5, 1.0),
          // wandering motion parameters
          wiggleAmp,
          wiggleSpeed,
          wigglePhase: rand(0, Math.PI * 2)
        };
      }

      // Create a particle of a specific kind at an optional (x,y)
      function createParticleOf(kind = 'dot', x = null, y = null) {
        const isHeart = kind === 'heart';
        const size = isHeart ? rand(6, 12) : rand(0.6, 2.2);
        const wiggleAmp = rand(WIGGLE_AMP_RANGE[0], WIGGLE_AMP_RANGE[1]);
        const wiggleSpeed = rand(WIGGLE_SPEED_RANGE[0], WIGGLE_SPEED_RANGE[1]);
        return {
          x: x == null ? rand(0, canvas.clientWidth) : x,
          y: y == null ? canvas.clientHeight + rand(2, 180) : y,
          vx: rand(-0.15, 0.15),
          vy: isHeart ? rand(-0.35, -0.9) : rand(-0.4, -1.4),
          size,
          life: rand(320, 1200),
          age: 0,
          rotation: rand(0, Math.PI * 2),
          spin: rand(-0.01, 0.01),
          alpha: 0,
          kind: isHeart ? 'heart' : 'dot',
          hue: isHeart ? (Math.random() < 0.6 ? rand(340, 360) : rand(0, 20)) : rand(30, 80),
          maxAlpha: PARTICLE_OPACITY * rand(0.5, 1.0),
          wiggleAmp,
          wiggleSpeed,
          wigglePhase: rand(0, Math.PI * 2)
        };
      }

      // Create a small cluster of hearts + dots around (cx, cy)
      function createCluster(cx, cy, hearts = 2, dots = 8, radius = CLUSTER_RADIUS_BASE) {
        const r = Math.max(24, Math.min(radius, canvas.clientWidth * 0.2));
        for (let i = 0; i < hearts && particles.length < MAX_PARTICLES; i++) {
          const angle = rand(0, Math.PI * 2);
          const dist = rand(0, r);
          const x = cx + Math.cos(angle) * dist + rand(-8, 8);
          const y = cy + Math.sin(angle) * dist + rand(-8, 8);
          particles.push(createParticleOf('heart', x, y));
        }
        for (let i = 0; i < dots && particles.length < MAX_PARTICLES; i++) {
          const angle = rand(0, Math.PI * 2);
          const dist = rand(0, r);
          const x = cx + Math.cos(angle) * dist + rand(-6, 6);
          const y = cy + Math.sin(angle) * dist + rand(-6, 6);
          particles.push(createParticleOf('dot', x, y));
        }
      }

      function drawHeart(ctx, x, y, size, rotation, color, alpha) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.scale(size / 16, size / 16);
        ctx.beginPath();
        ctx.moveTo(0, -6);
        ctx.bezierCurveTo(6, -18, 26, -18, 26, -6);
        ctx.bezierCurveTo(26, 8, 13, 20, 0, 30);
        ctx.bezierCurveTo(-13, 20, -26, 8, -26, -6);
        ctx.bezierCurveTo(-26, -18, -6, -18, 0, -6);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.globalAlpha = alpha;
        ctx.fill();
        ctx.restore();
        ctx.globalAlpha = 1;
      }

      function drawDot(ctx, x, y, size, color, alpha) {
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.globalAlpha = alpha;
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        ctx.globalAlpha = 1;
      }

      function step() {
        // Occasionally spawn a cluster (hearts + dots) so user sees both together
        if (particles.length < MAX_PARTICLES) {
          if (Math.random() < CLUSTER_CHANCE) {
            const cx = rand(canvas.clientWidth * 0.25, canvas.clientWidth * 0.75);
            const cy = rand(canvas.clientHeight * 0.6, canvas.clientHeight * 0.95);
            const hearts = Math.floor(rand(CLUSTER_HEARTS_MIN, CLUSTER_HEARTS_MAX + 1));
            const dots = Math.floor(rand(CLUSTER_DOTS_MIN, CLUSTER_DOTS_MAX + 1));
            const radius = CLUSTER_RADIUS_BASE * (canvas.clientWidth / 1000);
            createCluster(cx, cy, hearts, dots, radius);
          } else if (Math.random() < SPAWN_CHANCE) {
            particles.push(createParticle());
          }
        }

        ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];

          // gentle wandering: sinusoidal lateral motion + small vertical wobble
          const wiggleX = Math.sin(p.age * p.wiggleSpeed + p.wigglePhase) * p.wiggleAmp;
          const wiggleY = Math.cos(p.age * (p.wiggleSpeed * 0.6) + p.wigglePhase) * 0.25;

          p.x += p.vx + wiggleX;
          p.y += p.vy + wiggleY;

          // slower damping to keep particles drifting
          p.vx *= 0.997;
          p.vy *= 0.9995;
          p.rotation += p.spin * 0.8;
          p.age++;

          // fade in/out using particle's maxAlpha (keeps opacity lower)
          if (p.age < 30) p.alpha = p.maxAlpha * (p.age / 30);
          else if (p.age > p.life - 60) p.alpha = p.maxAlpha * Math.max(0, (p.life - p.age) / 60);
          else p.alpha = p.maxAlpha;

          const color = `hsl(${p.hue}, 70%, ${p.kind === 'heart' ? '60%' : '85%'})`;

          if (p.kind === 'heart') {
            drawHeart(ctx, p.x, p.y, p.size, p.rotation, color, p.alpha);
          } else {
            drawDot(ctx, p.x, p.y, p.size, color, p.alpha * 0.9);
          }

          // Remove if off-screen or past life (wider bounds to allow drifting)
          if (p.y < -120 || p.age > p.life || p.x < -160 || p.x > canvas.clientWidth + 160) {
            particles.splice(i, 1);
          }
        }

        requestAnimationFrame(step);
      }

      // start
      step();

      // gentle pulse spawning near the selection cards for effect
      setInterval(() => {
        if (particles.length < MAX_PARTICLES) {
          const cx = canvas.clientWidth * 0.5 + rand(-120, 120);
          const cy = canvas.clientHeight * 0.78 + rand(-20, 40);
          const hearts = Math.max(1, Math.floor(PULSE_COUNT * 0.12));
          const dots = Math.floor(PULSE_COUNT * 0.88);
          const radius = Math.max(36, canvas.clientWidth * 0.12);
          createCluster(cx, cy, hearts, dots, radius);
        }
      }, 700);

    })();

  </script>
</body>
<canvas id="particle-canvas" class="particles" style="position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:0;"></canvas>
<script>
    // Particles: denser small circles, big glows and heart particles with connecting lines
    (function(){
      const canvas = document.getElementById('particle-canvas');
      if(!canvas) return;
      const ctx = canvas.getContext('2d');
      let w = canvas.width = innerWidth;
      let h = canvas.height = innerHeight;
      let particles = [];
      let bigParticles = [];
      let hearts = [];
      const PARTICLE_COUNT = Math.min(600, Math.floor((w*h)/12000));
      const BIG_PARTICLE_COUNT = Math.max(6, Math.floor((w*h)/800000));
      const HEART_COUNT = Math.max(6, Math.floor((w*h)/1000000));
      const LINE_DIST = 100; // shorter threshold to limit line drawing

      function resize(){ w = canvas.width = innerWidth; h = canvas.height = innerHeight; init(); }
      window.addEventListener('resize', resize);

      function rand(min,max){ return min + Math.random()*(max-min); }

      function init(){
        particles = []; bigParticles = []; hearts = [];
        for(let i=0;i<PARTICLE_COUNT;i++){
          particles.push({ x: rand(0,w), y: rand(0,h), r: rand(0.8,3.6), vx: rand(-0.5,0.5), vy: rand(-0.5,0.5), a: rand(0.06,0.48) });
        }
        for(let i=0;i<BIG_PARTICLE_COUNT;i++){
          bigParticles.push({ x: rand(0,w), y: rand(0,h), r: rand(8,20), vx: rand(-0.12,0.12), vy: rand(-0.12,0.12), a: rand(0.04,0.18) });
        }
        for(let i=0;i<HEART_COUNT;i++){
          hearts.push({ x: rand(0,w), y: rand(0,h), r: rand(6,14), vx: rand(-0.15,0.15), vy: rand(-0.15,0.15), a: rand(0.5,0.9), rot: rand(0,Math.PI*2) });
        }
      }

      function drawHeart(p){
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.beginPath();
        ctx.moveTo(0, -p.r/2);
        ctx.bezierCurveTo(p.r/2, -p.r, p.r, -p.r/4, 0, p.r/2);
        ctx.bezierCurveTo(-p.r, -p.r/4, -p.r/2, -p.r, 0, -p.r/2);
        ctx.closePath();
        const g = ctx.createLinearGradient(-p.r, -p.r, p.r, p.r);
        g.addColorStop(0, `rgba(255,90,120,${p.a})`);
        g.addColorStop(1, `rgba(255,160,180,${p.a*0.9})`);
        ctx.fillStyle = g;
        ctx.fill();
        ctx.restore();
      }

      function step(){
        ctx.clearRect(0,0,w,h);

        // big glows
        for(const bp of bigParticles){
          bp.x += bp.vx; bp.y += bp.vy;
          if(bp.x < -50) bp.x = w + 50; if(bp.x > w+50) bp.x = -50;
          if(bp.y < -50) bp.y = h + 50; if(bp.y > h+50) bp.y = -50;
          const g = ctx.createRadialGradient(bp.x,bp.y,0,bp.x,bp.y,bp.r*2);
          g.addColorStop(0, `rgba(255,220,230,${bp.a})`);
          g.addColorStop(0.5, `rgba(255,150,160,${bp.a*0.6})`);
          g.addColorStop(1, 'rgba(255,150,160,0)');
          ctx.fillStyle = g;
          ctx.beginPath(); ctx.arc(bp.x,bp.y,bp.r*1.6,0,Math.PI*2); ctx.fill();
        }

        // hearts
        for(const hP of hearts){
          hP.x += hP.vx; hP.y += hP.vy; hP.rot += 0.008;
          if(hP.x < -50) hP.x = w + 50; if(hP.x > w+50) hP.x = -50;
          if(hP.y < -50) hP.y = h + 50; if(hP.y > h+50) hP.y = -50;
          drawHeart(hP);
        }

        // small particles
        for(let i=0;i<particles.length;i++){
          const p = particles[i];
          p.x += p.vx; p.y += p.vy;
          if(p.x < -10) p.x = w + 10; if(p.x > w+10) p.x = -10;
          if(p.y < -10) p.y = h + 10; if(p.y > h+10) p.y = -10;
          ctx.beginPath(); ctx.fillStyle = `rgba(255,200,210,${p.a})`; ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
        }

        // small-to-small lines (sampled to limit loops)
        const STEP = Math.max(1, Math.floor(particles.length/180));
        for(let i=0;i<particles.length;i+=STEP){
          const pa = particles[i];
          for(let j=i+1;j<particles.length && j<i+1+80;j++){
            const pb = particles[j];
            const dx = pa.x - pb.x, dy = pa.y - pb.y, d = Math.sqrt(dx*dx + dy*dy);
            if(d < LINE_DIST){
              const alpha = (1 - d/LINE_DIST) * 0.11;
              ctx.beginPath(); ctx.strokeStyle = `rgba(255,190,200,${alpha*0.9})`; ctx.lineWidth = 0.8; ctx.moveTo(pa.x,pa.y); ctx.lineTo(pb.x,pb.y); ctx.stroke();
            }
          }
        }

        // lines from small particles to hearts
        for(let i=0;i<particles.length;i+=STEP){
          const pa = particles[i];
          for(const hb of hearts){
            const dx = pa.x - hb.x, dy = pa.y - hb.y, d = Math.sqrt(dx*dx + dy*dy);
            if(d < LINE_DIST*1.2){
              const alpha = (1 - d/(LINE_DIST*1.2)) * 0.08;
              ctx.beginPath(); ctx.strokeStyle = `rgba(255,150,170,${alpha})`; ctx.lineWidth = 0.9; ctx.moveTo(pa.x,pa.y); ctx.lineTo(hb.x,hb.y); ctx.stroke();
            }
          }
        }

        // small-to-big lines (sparse)
        for(let i=0;i<particles.length;i+=STEP*2){
          const pa = particles[i];
          for(const bp of bigParticles){
            const dx = pa.x - bp.x, dy = pa.y - bp.y, d = Math.sqrt(dx*dx + dy*dy);
            if(d < LINE_DIST*1.3){
              const alpha = (1 - d/(LINE_DIST*1.3)) * 0.06;
              ctx.beginPath(); ctx.strokeStyle = `rgba(255,200,210,${alpha})`; ctx.lineWidth = 0.7; ctx.moveTo(pa.x,pa.y); ctx.lineTo(bp.x,bp.y); ctx.stroke();
            }
          }
        }

        requestAnimationFrame(step);
      }

      init(); step();
    })();
  </script>
</html>
